<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>gform application</title>

    <!-- Bootstrap -->
    <link href="/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/components-font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/highlight/styles/github.css">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel='stylesheet' href='/assets/css/main.css'></style>
    
  </head>
  <body>
        <nav class="navbar navbar-default">
         <div class="container-fluid">
         <!-- Brand and toggle get grouped for better mobile display -->
         <div class="navbar-header">
         <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
         <span class="sr-only">Toggle navigation</span>
         <span class="icon-bar"></span>
         <span class="icon-bar"></span>
         <span class="icon-bar"></span>
         </button>
         <a class="navbar-brand" href="/index.html">home</a>
         </div>
        
         <!-- Collect the nav links, forms, and other content for toggling -->
         <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
         <ul class="nav navbar-nav">
         <li ><a href="/cms4apps.html">cms4apps</a></li>
         <li ><a href="/mongomat.html">Mongomat</a></li>
         <li class="active"><a href="/gform-app.html">gform application</a></li>
         </div><!-- /.navbar-collapse -->
         </div><!-- /.container-fluid -->
        </nav>
<div class="container"/>
<div class="row">
    <div class="col-md-9" style="position:relative">
        <h1>gform application</h1>
        <p></p>
            <h2 id="nav_0" class="page-header">1. Introduction</h2>
            
<p> A framework to rapidly create administrative uis such as database clients or cms.
 Supports creation of master and detail views based on schemas. Also supports
 creation of schemas in the ui, which is the essential ingredient to create a cms.</p>
            <h2 id="nav_1" class="page-header">2. examples</h2>
            
<h3 id="applications">applications</h3>
<p><strong>mongomat</strong></p>
<p>An admin ui for mongodb 
This is an example of the dynamic resources approach. Stores and schemas can be created and modified at runtime.
<a title="null"href="/mongomat.html">more..</a></p>
<p><strong>cms4apps</strong></p>
<p>A cms that supports different deployment scenarios: Github pages, mongodb or any 
dynamically typed store with a restful interface.
<a title="null"href="/cms4apps.html">more..</a></p>
<p><strong>mongoose admin example</strong></p>
<p>An example of how to create an admin ui for <a title="null"href="http://mongoosejs.com/">mongoose</a> (<a title="null"href="http://github.com/stemey/mongoose-administration-example">More</a>).
This is an example of the static resources approach. All stores and schemas are defined externally and do not
change.</p>
<h3 id="demos">demos</h3>
<p>The following examples use localstorage to persist data. Check them out in the browser</p>
<p><strong><a title="null"href="http://toobop.net/gform-app/static.html">static</a></strong></p>
<p>A simple example a single store with a single static schema:</p>
<p><strong><a title="null"href="http://toobop.net/gform-app/cms.html">cms4apps</a></strong></p>
<p>A cms that uses handlebars for rendering.</p>
<p>An example of a single store with its documents forming a tree structure. Documents are individually associated to schemas
by a discriminator property. Each schema has a template. The gui provides a tree view, a preview and a details editor. </p>
<p>The cms does not provide a way to statically generate the site or dynamically serve it either. It is up to the developer to write an application
that uses the content and templates from the cms. Usually applications use extra logic and more data sources to render 
the pages. This extra information can be mocked in the cms using extra data. For example the login information of the current
user are replaced by static mock data in the cms.</p>
<p><strong><a title="null"href="http://toobop.net/gform-app/dynamic.html">dynamic</a></strong></p>
<p>An example of a dynamic resource factory, which provides a way to dynamically create new schemas and stores.</p>
            <h2 id="nav_2" class="page-header">3. domain</h2>
            
<p>The domain model explains how gform applications are
composed of entities, stores and schemas. In the following there will be references to the so called appContext.
It is a global object that provides access to stores and schemas.</p>
<div>
    <h3 id="subnav_2_1">3.2 entity</h3>
<p>Entities are json documents. An entity is contained in a store.  An entity has  an  id. 
This id needs to be unique across all entities in its store.</p>
<p>An entity has an associated schema that it conforms to. There are stores with a single 
schema that all its entitites conform to. And there are stores that have a set of schemas.
In this case each entity defines its schema by a type discrimator property called typeProperty.</p>
<p>To retrieve an entity&#39;s schema there are two ways:</p>
<ol>
<li><p>All entities in the store have the same type.
<code>store.template</code>is the id of the schema. To retrieve it use <code>schemaRegistry.get(id)</code>. SchemaRegistry
is a registry for all schemas that is available via the glabal AppContext object.</p>
</li>
<li><p>The store contains entities of different types.
 An entity&#39;s type is defined by its typeProperty. The name of the typeProperty is retrieved from <code>store.typeProperty</code>.
To retrieve the the schema from the schemaRegistry you need to prefix the typeProperty&#39;s value with <code>store.templateStore</code>.</p>
</li>
</ol>
<pre><code class="lang-javascript">var promise = appContext.getSchema(store.templateStore+&quot;/&quot;+entity[store.typeProperty];
// equivalent to
var promise = appContext.getStore(store.templateStore).get(entity[store.typeProperty])
</code></pre>
</div><div>
    <h3 id="subnav_2_2">3.3 store</h3>
<p>An entity is a json document which is accessed via a store. A store provides access to entities via http or it serves them from a browser storage.
Each entity in a store has an associated schema.</p>
<div class="center-block caption-fix">
    <img src="http://www.plantuml.com/plantuml/img/RL71Ri8m3BtxAt9a1r0FE_K0N3Q96nByW4ciDfARbiJLLB7z-vm1LJgHG-Bt_FnY9_ia66Ni69959lDULURBEsa1B6DAfXjPV98-ahc1qINJGCVO3nHbgasIw4DpJr0tC0gTidZE_3oDaYAcXTEZu8MsK7dtyZRlpjh8RkR8UItwHAkxAZzA2Ehfcu0NfeFRrPU-Py80jiNGq7-s8LczrO3EvMCO_z1rf3Zbm16JK8wCoVqMpxDUVs_ldKCvQq7FuzcMEjJvr60XtJvIIzidQ-fgima0UmfEV-mN" class="center-block img-responsive" alt="" />
    <div class="caption">
        <p >The class diagram for store and schema</p>
    </div>
</div>
<p>Stores are an extension of <code>dojo/store</code> and have the following properties (in addition to the ones defined by <code>dojo/store</code>):</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>name</th>
<th>description</th>
<th style="text-align:center">required</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>the store identifier</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td>idProperty</td>
<td>the name of the property that holds the primary key - inherited from &#39;dojo/store&#39;.</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td>idType</td>
<td>the type of the idProperty. Used to generate a default schema for a store.</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>typeProperty</td>
<td>the property which holds the type discriminator</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>templateStore</td>
<td>provides the schemas for this store</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>template</td>
<td>if all entities have the same type this is the type discriminator</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>assignableId</td>
<td>whether or not the user may initially set the id</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>changeableId</td>
<td>if true then the user has to pick the id and can change it. Usually this is used for file based stores. The id is the path of the file.</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>editorFactory</td>
<td>defines the binding of schemas and its attributes to widgets. Also defines actions like &quot;save&quot;, &quot;delete&quot;, &quot;discard&quot; that are displayed in the detail editor.</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>previewerId</td>
<td>When an entity of this store is focusses and the previewerId is set then the previewer will display the entity.</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>To get the actual store implementation from the store&#39;s name:</p>
<pre><code class="lang-javascript">// require dojo/when
var store = appContext.getStore(&quot;/users&quot;);
when(store.get(123)).then(function(user) {...};
</code></pre>
<p>Either the store has a template property or both a typeProperty and the templateStore property.</p>
<p>Store is an abstraction to access entities. Stores have a simple api and can be used to access data from different systems:
browser stores like IndexDB, LocalStorage or server side stores providing access via rest.</p>
<p>A store provides functions to create, update, read, query and delete entities. Stores use promises as return values for
asynchronuos access but fallback to simple valus for synchronuos access.</p>
<h4 id="read-a-single-entity-by-id">Read a single entity by id</h4>
<p>Deading a single entity by its id is done via <code>store.get(id)</code>. The implementation is pretty straight forward and the
result is the entity itself.</p>
<h4 id="delete-a-single-entity-by-id">Delete a single entity by id</h4>
<p>Deleting a single entity is done via <code>store.delete(id)</code>. The return value is unimportant.</p>
<h4 id="update-a-single-entity">Update a single entity</h4>
<p>Updating is done via <code>store.put(entity)</code>. The id is taken from the entity. The return value is usually not important.
Their are cases where version information or similar things are updated in the entity as well. This change is currently not
visible after saving an updated entity.</p>
<h4 id="create-an-entity">Create an entity</h4>
<p>Creating an entity is done via <code>store.add(entity)</code>. The return value is either the generated id or the updated entity. In either case
the entity is reloaded to reflect all changes.</p>
<h4 id="query-entities">Query entities</h4>
<p>This is the function that needs the most work when connecting to a new data store. The function is <code>store.query(query,options)</code>.
See documentation on parameter <a title="null"href="dojotoolkit.html">here</a>. The dojo store abstraction is not perfect in this regard. Usually
there are two kinds of queries that the store implementor needs to take into consideration. One is issued by <code>dijit/FilteringSelet</code>
and the other by <code>gridx/Grid</code>. <strong>TODO</strong>: more on implementing your own store </p>
<h4 id="tree">tree</h4>
<p>A store can contain a tree of entities (See <a title="null"href="dojotoolkit.html">here</a>). There are two ways to implement this behavior in gform-app.
Either all entities except the root have a parent identified by its id. Then the store needs to provide a <code>parentProperty</code>. Or the id of the
ntities is also their path in the tree.</p>
</div><div>
    <h3 id="subnav_2_3">3.4 schema</h3>
<p>A schema defines the attributes (properties) an entity can or must have. These schemas are usually gform schema documents that are perfect to create
a form to edit its instances. Schemas can allow additional dynamic properties that are not restricted by the schema.</p>
<p>To programmatically get hold of the schema:</p>
<pre><code class="lang-javascript">// require dojo/when
when(appContext.getSchema(&quot;mySchema&quot;)).then(function(schema) {
    //
})
</code></pre>
<p>Schemas can either be stored as simple json files or linked json files.</p>
<h4 id="simple-json-files">simple json files</h4>
<pre><code class="lang-json">{
  &quot;editor&quot;:&quot;listpane&quot;,
  &quot;attributes&quot;:[
     {
        &quot;code&quot;:&quot;name&quot;,
        &quot;type&quot;:&quot;string&quot;,
        &quot;editor&quot;:&quot;richtext&quot;
     }
  ]
}
</code></pre>
<h4 id="linked-json-files">linked json files</h4>
<pre><code class="lang-json">{
  &quot;attributes&quot;:[
     {
        &quot;code&quot;:&quot;embedded&quot;,
        &quot;type&quot;:&quot;object&quot;,
        &quot;group&quot;:{&quot;$ref&quot;:&quot;./embedded-schemas.json&quot;}
     }
  ]
}
</code></pre>
<p>To actually create the schema object from these json files:</p>
<pre><code class="lang-javascript">// require &#39;gform/util/Resolver&#39;
var resolver = new Resolver();
var schemaPromise = resolver.resolve(schema);
schemaPromise.then(function () {
  // schema is now modified
})
</code></pre>
<p>There are actually more involved ways to create a schema from a set of linked json files.</p>
<h4 id="store">store</h4>
<p> Schemas can be stored in a store. Each store has a name and the schemas are identified by a url <code>&lt;storeName&gt;/&lt;schemaId&gt;</code>.</p>
<pre><code>var promise = appContext.getSchema(&quot;mySchemas/schema1&quot;);
</code></pre><h4 id="gform-schema-editor">gform schema editor</h4>
<p>It is often useful to create a meta schema which describes a form that is
used to create new schemas. This is useful for a cmsto create new content types or
a dynamic database client to create a new schema. </p>
<p>There is a standard set of json files that describe all groups and attributes
available in gform. These can be composed filtered and extended to create
the ideal meta schema.</p>
</div>            <h2 id="nav_3" class="page-header">4. application</h2>
            
<p>The frontend of the is composed of dojo widgets. The main widgets are as follows</p>
<div>
    <h3 id="subnav_3_1">4.2 widget</h3>
<p>The frontend of the is composed of dojo widgets. The main widgets are as follows</p>
<ul>
<li>BorderContainer </li>
<li>asd</li>
<li></li>
</ul>
<div class="center-block caption-fix">
    <img src="http://www.plantuml.com/plantuml/img/TPBDRi8m48JlVWgVAo651-021zf3LIGGToUU9aQM7MqME23UlNPZEn4_jyZppUnudQ5H5d9PLPMy6isTyFK93Skr9mtQUCVAE92yYRl8si5xMwjuHcYDTolsVPGVFH-BHMQBTqDGZFMPsRinDAT5UguMoz7W-WrtViQp8WgxPq-8nm6MgPt5Bx-hL_YIi5Cj3eGI8kKGcI-zweCISwOPCM7Ebv0jmW1bjsHqoddoFI3J5NQ4o-X9_Hiu1its_wcSjWXB61Bx_pvz_WvLkq94MqwCOrzuNoucgTERg_gdn_Wdf5vaskxjOWiln1y0" class="center-block img-responsive" alt="" />
    <div class="caption">
        <p >A widget tree example</p>
    </div>
</div>
</div><div>
    <h3 id="subnav_3_2">4.3 AppContext</h3>
<p>The appContext is made available to all widgets during construction.
All stores and schemas are available via the AppContext.
The AppContext also manages the current navigation state.</p>
<p>The app&#39;s global state is managed by <code>gform/AppContext</code>:</p>
<p>properties:</p>
<ul>
<li>storeId: the currently selected store. Each store is associated with a customer view.</li>
<li>schemaRegistry: global registry for schemas </li>
<li>storeRegistry:global registry for stores</li>
</ul>
<p>All components have access to the AppContext during initialization.</p>
</div><div>
    <h3 id="subnav_3_3">4.4 StoreRegistry</h3>
<p>All stores are available via the storeRegistry.
The stores can be added and removed to the storeRegistry at runtime.</p>
</div><div>
    <h3 id="subnav_3_4">4.5 SchemaRegistry</h3>
<p>The schemaRegistry provides access to all schemas.
Schemas can be added and removed from it at runtime.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>method</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>get(id)</td>
<td>get schema by id</td>
</tr>
<tr>
<td>register(id, schema)</td>
<td>register a schema</td>
</tr>
<tr>
<td>unregister(id)</td>
<td>unregister schema</td>
</tr>
<tr>
<td>registerStore(name,store)</td>
<td>register a store that contains schemas. A schema&#39;s id is <code>store.name+&quot;/&quot;+entityId</code></td>
</tr>
<tr>
<td>unregisterStore(name)</td>
<td>unregister a store that contains schemas</td>
</tr>
</tbody>
</table>
<p>The stores that contain schemas are special stores in that the get method
will not only return the stored json assuming its a schema. If the schema includes
links to external schemas then these will be loaded and the schemas will be substituted for the links.
This is done recursively.</p>
</div><div>
    <h3 id="subnav_3_5">4.6 schemas</h3>
<p>Schemas are registered with a SchemaRegistry.
There are static schemas that are known 
at startup tie and don&#39;t change. Then there are schemas
that are stored in a store. They may or may not be modifiable.
If schemas stored in a store are modifiable
they are entities of the store and have a schema themselves.
This metaschema describes all possible attributes the schema may have.
Usually there will be a way for the user to edit or
create a new schema by using the form generated from this
metaschema.</p>
<h4 id="static-schema">static schema</h4>
<p>A static schema can be a single json file.</p>
</div>            <h2 id="nav_4" class="page-header">5. messages</h2>
            
<p>The loosely coupled components in gform-app communicate via <code>dojo/topic</code> messages.</p>
<h3 id="entity">entity</h3>
<p>these messages handle entities.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>message</th>
<th>event</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/focus</td>
<td>storeName,id, source, template</td>
<td>an entity was selected (e.g. in a grid or in a detail tab container).</td>
</tr>
<tr>
<td>/new</td>
<td>storeName, schemaUrl, source, value</td>
<td>open an editor for a new entity (e.g. a toolbar button publishes this event to open a new editor)</td>
</tr>
<tr>
<td>/deleted</td>
<td>storeName, id, entity?, source</td>
<td>an entity was deleted.</td>
</tr>
<tr>
<td>/updated</td>
<td>storeName, id ,entity?, oldEntity?,  source</td>
<td>an entity was updated.</td>
</tr>
<tr>
<td>/added</td>
<td>storeName, id , entity, source</td>
<td>an new entity was persisted.</td>
</tr>
<tr>
<td>/modify/update</td>
<td>storeName, id, value</td>
<td>an entity was changed but its changes are not persisted yet. This event is used by peviewers to display the transient state.</td>
</tr>
<tr>
<td>/modify/cancel</td>
<td>storeName, id</td>
<td>an entity&#39;s editing session was cancelled.</td>
</tr>
</tbody>
</table>
<h3 id="store">store</h3>
<p>these messages handle stores.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>message</th>
<th>event</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/store/focus</td>
<td>store, source</td>
<td>a store was selected.</td>
</tr>
<tr>
<td>/store/new</td>
<td>store, source</td>
<td>a new stored was persisted.</td>
</tr>
<tr>
<td>/store/deleted</td>
<td>store, entity, source</td>
<td>a store was deleted.</td>
</tr>
<tr>
<td>/store/updated</td>
<td>store, entity?, oldEntity?, source</td>
<td>a store was updated.</td>
</tr>
</tbody>
</table>
<h3 id="examples">examples</h3>
<p>Here are some examples how messages are used to drive the ui.</p>
<h4 id="create-a-new-entity">create a new entity</h4>
<p>The toolbar button &quot;add&quot; publishes a <code>/new</code> event. The <code>TabOpener</code> is subscribed to the message and creates a new tab with 
 a corresponding editor.</p>
<h4 id="select-an-entity">select an entity</h4>
<p>The grid and Tab components publish <code>focus</code> events when a new entity is selected/focussed. The TabOpener is also  subscribed to 
 the message. The Tab Opener opens an editor. The BorderContainer that displays a whole view switches to the view that is associated with the 
 entity&#39;s store.</p>
<h4 id="live-preview">live preview</h4>
<p>A previewer can be used to display a view for an entity that is being modified. One example is an entity that is a gform schema itself. The schemaPreviewer which 
displays the editor described by the gform schema. Another example is a entity that has an associated handlebars template.
The Previewer will render the template with the entity as the input data. 
To provide an update to the rendered view based while the user changes the entity but beofre it is saved the previwer listens to <code>/modify/update</code>
messages. </p>
            <h2 id="nav_5" class="page-header">6. project</h2>
            
<p>the project is hosted on github. <a title="null"href="http://github.com/stemey/gform-app">more..</a></p>
<h3 id="installation">installation</h3>
<pre><code class="lang-sh">git clone www.github.com/stemey/gform-app
cd gform-app
bower install
</code></pre>
<p>open browser to load examples: /src/gform-app/examples/?.html</p>
<p>to optimize te javascript:</p>
<pre><code class="lang-sh">npm install
grunt build
</code></pre>
<p>open browser to load examples: /dist/gform-app/examples/?.html</p>
<h3 id="test">Test</h3>
<pre><code class="lang-sh">grunt test
</code></pre>
<p>open in browser: /node_modules/intern/client.html?config=src/gform-app/tests/intern</p>
    </div>
    <div class="col-md-3">
        <nav id="navigation" class="bs-docs-sidebar affix">
            <ul class="nav bs-docs-sidenav">
                <li>
                    <a href="#nav_0">Introduction</a>
                    <ul class="nav">
                        <li>
                            <a href="#subnav_0_0"></a>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="#nav_1">examples</a>
                    <ul class="nav">
                        <li>
                            <a href="#subnav_1_0"></a>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="#nav_2">domain</a>
                    <ul class="nav">
                        <li>
                            <a href="#subnav_2_0"></a>
                        </li>
                        <li>
                            <a href="#subnav_2_1">entity</a>
                        </li>
                        <li>
                            <a href="#subnav_2_2">store</a>
                        </li>
                        <li>
                            <a href="#subnav_2_3">schema</a>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="#nav_3">application</a>
                    <ul class="nav">
                        <li>
                            <a href="#subnav_3_0"></a>
                        </li>
                        <li>
                            <a href="#subnav_3_1">widget</a>
                        </li>
                        <li>
                            <a href="#subnav_3_2">AppContext</a>
                        </li>
                        <li>
                            <a href="#subnav_3_3">StoreRegistry</a>
                        </li>
                        <li>
                            <a href="#subnav_3_4">SchemaRegistry</a>
                        </li>
                        <li>
                            <a href="#subnav_3_5">schemas</a>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="#nav_4">messages</a>
                    <ul class="nav">
                        <li>
                            <a href="#subnav_4_0"></a>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="#nav_5">project</a>
                    <ul class="nav">
                        <li>
                            <a href="#subnav_5_0"></a>
                        </li>
                    </ul>
                </li>
            </ul>
        </nav>
    </div>
</div>
    
    <footer class="footer">
        <p>created with cms<span style="color:red">4</span>apps</p>
    </footer>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="/jquery/dist/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/bootstrap/dist/js/bootstrap.js"></script>
    <script src="gform-app/controller/mock.js"></script>
    <script>$('body').scrollspy({ target: '#navigation' })</script>
  </body>
</html>